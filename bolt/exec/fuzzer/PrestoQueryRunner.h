/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * --------------------------------------------------------------------------
 * Copyright (c) ByteDance Ltd. and/or its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 *
 * This file has been modified by ByteDance Ltd. and/or its affiliates on
 * 2025-11-11.
 *
 * Original file was released under the Apache License 2.0,
 * with the full license text available at:
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * This modified file is released under the same license.
 * --------------------------------------------------------------------------
 */

#pragma once

#include <folly/SocketAddress.h>
#include <folly/io/async/EventBaseThread.h>
#include "bolt/common/memory/Memory.h"
#include "bolt/exec/fuzzer/ReferenceQueryRunner.h"
#include "bolt/vector/ComplexVector.h"
namespace bytedance::bolt::exec::test {
class PrestoQueryRunner : public bolt::exec::test::ReferenceQueryRunner {
 public:
  /// @param coordinatorUri Presto REST API endpoint, e.g. http://127.0.0.1:8080
  /// @param user Username to use in X-Presto-User header.
  /// @param timeout Timeout in milliseconds of an HTTP request.
  PrestoQueryRunner(
      std::string coordinatorUri,
      std::string user,
      std::chrono::milliseconds timeout = std::chrono::milliseconds{1000});

  /// Converts Bolt query plan to Presto SQL. Supports Values -> Aggregation or
  /// Window with an optional Project on top.
  ///
  /// Values node is converted into reading from 'tmp' table.
  ///
  /// @return std::nullopt if Values node uses types not supported by DWRF file
  /// format (DATE, INTERVAL, UNKNOWN).
  std::optional<std::string> toSql(
      const bolt::core::PlanNodePtr& plan) override;

  /// Creates 'tmp' table using specified data, executes SQL query generated by
  /// 'toSql' and returns the results.
  ///
  /// @param sql SQL generated by 'toSql' method.
  /// @param input Data used in the Values node in the plan passed to 'toSql'
  /// method.
  /// @param resultType Expected type of the results.
  /// @return Data received from Presto.
  std::multiset<std::vector<bolt::variant>> execute(
      const std::string& sql,
      const std::vector<bolt::RowVectorPtr>& input,
      const bolt::RowTypePtr& resultType) override;

  /// Executes Presto SQL query and returns the results. Tables referenced by
  /// the query must already exist.
  std::vector<bolt::RowVectorPtr> execute(const std::string& sql);

  bool supportsBoltVectorResults() const override;

  std::vector<RowVectorPtr> executeVector(
      const std::string& sql,
      const std::vector<RowVectorPtr>& input,
      const RowTypePtr& resultType) override;

 private:
  bolt::memory::MemoryPool* rootPool() {
    return rootPool_.get();
  }

  bolt::memory::MemoryPool* pool() {
    return pool_.get();
  }

  std::optional<std::string> toSql(
      const std::shared_ptr<const bolt::core::AggregationNode>&
          aggregationNode);

  std::optional<std::string> toSql(
      const std::shared_ptr<const bolt::core::WindowNode>& windowNode);

  std::optional<std::string> toSql(
      const std::shared_ptr<const bolt::core::ProjectNode>& projectNode);

  std::string startQuery(const std::string& sql);

  std::string fetchNext(const std::string& nextUri);

  const std::string coordinatorUri_;
  const std::string user_;
  const std::chrono::milliseconds timeout_;
  folly::EventBaseThread eventBaseThread_{false};
  std::shared_ptr<bolt::memory::MemoryPool> rootPool_{
      bolt::memory::memoryManager()->addRootPool()};
  std::shared_ptr<bolt::memory::MemoryPool> pool_{
      rootPool_->addLeafChild("leaf")};
};

} // namespace bytedance::bolt::exec::test
