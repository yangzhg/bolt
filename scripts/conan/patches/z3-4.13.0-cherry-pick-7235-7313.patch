diff --git a/recipes/z3/all/conandata.yml b/recipes/z3/all/conandata.yml
index 3b0eba58..17369fc2 100644
--- a/recipes/z3/all/conandata.yml
+++ b/recipes/z3/all/conandata.yml
@@ -23,3 +23,8 @@ sources:
   "4.9.1":
     url: "https://github.com/Z3Prover/z3/archive/refs/tags/z3-4.9.1.tar.gz"
     sha256: "ca08ba933481242507b2f8b303c3ebdf5d16b0005d397fb45018321dc639a0d7"
+patches:
+  "4.13.0":
+    - patch_file: "patches/4.13.0-0001-cherry-pick-7235-7313.patch"
+      patch_description: "Fix compilation error, cherry pick 7335 7235"
+      patch_type: "portability"
diff --git a/recipes/z3/all/conanfile.py b/recipes/z3/all/conanfile.py
index 7d2773ee..4bae0d8c 100644
--- a/recipes/z3/all/conanfile.py
+++ b/recipes/z3/all/conanfile.py
@@ -4,7 +4,7 @@ from conan import ConanFile
 from conan.tools.build import check_min_cppstd
 from conan.tools.cmake import CMake, CMakeDeps, CMakeToolchain, cmake_layout
 from conan.tools.env import VirtualBuildEnv
-from conan.tools.files import get, copy, rmdir
+from conan.tools.files import apply_conandata_patches, export_conandata_patches, get, copy, rmdir
 from conan.tools.scm import Version
 
 required_conan_version = ">=2"
@@ -51,6 +51,9 @@ class Z3Conan(ConanFile):
     def build_requirements(self):
         self.tool_requires("cmake/[>=3.16 <4]")
 
+    def export_sources(self):
+        export_conandata_patches(self)
+
     def source(self):
         get(self, **self.conan_data["sources"][self.version], strip_root=True)
 
@@ -76,6 +79,7 @@ class Z3Conan(ConanFile):
         deps.generate()
 
     def build(self):
+        apply_conandata_patches(self)
         cmake = CMake(self)
         cmake.configure()
         cmake.build()
diff --git a/recipes/z3/all/patches/4.13.0-0001-cherry-pick-7235-7313.patch b/recipes/z3/all/patches/4.13.0-0001-cherry-pick-7235-7313.patch
new file mode 100644
index 00000000..c345857d
--- /dev/null
+++ b/recipes/z3/all/patches/4.13.0-0001-cherry-pick-7235-7313.patch
@@ -0,0 +1,118 @@
+diff --git a/src/math/lp/column_info.h b/src/math/lp/column_info.h
+index 1dc0c60c7..9cbeea66c 100644
+--- a/src/math/lp/column_info.h
++++ b/src/math/lp/column_info.h
+@@ -47,7 +47,7 @@ public:
+             m_lower_bound_is_strict == c.m_lower_bound_is_strict &&
+             m_upper_bound_is_set == c.m_upper_bound_is_set&&
+             m_upper_bound_is_strict == c.m_upper_bound_is_strict&&
+-            (!m_lower_bound_is_set || m_lower_bound == c.m_low_bound) &&
++            (!m_lower_bound_is_set || m_lower_bound == c.m_lower_bound) &&
+             (!m_upper_bound_is_set || m_upper_bound == c.m_upper_bound) &&
+             m_cost == c.m_cost &&
+             m_is_fixed == c.m_is_fixed &&
+diff --git a/src/math/lp/lp_settings.h b/src/math/lp/lp_settings.h
+index 08fd36505..4165fd33d 100644
+--- a/src/math/lp/lp_settings.h
++++ b/src/math/lp/lp_settings.h
+@@ -97,39 +97,41 @@ public:
+ };
+ 
+ struct statistics {
+-    unsigned m_make_feasible;
+-    unsigned m_total_iterations;
+-    unsigned m_iters_with_no_cost_growing;
+-    unsigned m_num_factorizations;
+-    unsigned m_num_of_implied_bounds;
+-    unsigned m_need_to_solve_inf;
+-    unsigned m_max_cols;
+-    unsigned m_max_rows;
+-    unsigned m_gcd_calls;
+-    unsigned m_gcd_conflicts;
+-    unsigned m_cube_calls;
+-    unsigned m_cube_success;
+-    unsigned m_patches;
+-    unsigned m_patches_success;
+-    unsigned m_hnf_cutter_calls;
+-    unsigned m_hnf_cuts;
+-    unsigned m_nla_calls;
+-    unsigned m_gomory_cuts;
+-    unsigned m_nla_add_bounds;
+-    unsigned m_nla_propagate_bounds;
+-    unsigned m_nla_propagate_eq;
+-    unsigned m_nla_lemmas;
+-    unsigned m_nra_calls;
+-    unsigned m_nla_bounds_improvements;
+-    unsigned m_horner_calls;
+-    unsigned m_horner_conflicts;
+-    unsigned m_cross_nested_forms;
+-    unsigned m_grobner_calls;
+-    unsigned m_grobner_conflicts;
+-    unsigned m_offset_eqs;
+-    unsigned m_fixed_eqs;
++    unsigned m_make_feasible = 0;
++    unsigned m_total_iterations = 0;
++    unsigned m_iters_with_no_cost_growing = 0;
++    unsigned m_num_factorizations = 0;
++    unsigned m_num_of_implied_bounds = 0;
++    unsigned m_need_to_solve_inf = 0;
++    unsigned m_max_cols = 0;
++    unsigned m_max_rows = 0;
++    unsigned m_gcd_calls = 0;
++    unsigned m_gcd_conflicts = 0;
++    unsigned m_cube_calls = 0;
++    unsigned m_cube_success = 0;
++    unsigned m_patches = 0;
++    unsigned m_patches_success = 0;
++    unsigned m_hnf_cutter_calls = 0;
++    unsigned m_hnf_cuts = 0;
++    unsigned m_nla_calls = 0;
++    unsigned m_gomory_cuts = 0;
++    unsigned m_nla_add_bounds = 0;
++    unsigned m_nla_propagate_bounds = 0;
++    unsigned m_nla_propagate_eq = 0;
++    unsigned m_nla_lemmas = 0;
++    unsigned m_nra_calls = 0;
++    unsigned m_nla_bounds_improvements = 0;
++    unsigned m_horner_calls = 0;
++    unsigned m_horner_conflicts = 0;
++    unsigned m_cross_nested_forms = 0;
++    unsigned m_grobner_calls = 0;
++    unsigned m_grobner_conflicts = 0;
++    unsigned m_offset_eqs = 0;
++    unsigned m_fixed_eqs = 0;
+     statistics() { reset(); }
+-    void reset() { memset(this, 0, sizeof(*this)); }
++    void reset() {
++        *this = statistics{};
++    }
+     void collect_statistics(::statistics& st) const {
+         st.update("arith-factorizations", m_num_factorizations);
+         st.update("arith-make-feasible", m_make_feasible);
+diff --git a/src/math/lp/static_matrix.h b/src/math/lp/static_matrix.h
+index 9d6bb8599..42dd476b5 100644
+--- a/src/math/lp/static_matrix.h
++++ b/src/math/lp/static_matrix.h
+@@ -79,7 +79,7 @@ public:
+         ref(static_matrix & m, unsigned row, unsigned col):m_matrix(m), m_row(row), m_col(col) {}
+         ref & operator=(T const & v) { m_matrix.set( m_row, m_col, v); return *this; }
+ 
+-        ref operator=(ref & v) { m_matrix.set(m_row, m_col, v.m_matrix.get(v.m_row, v.m_col)); return *this; }
++        ref operator=(ref & v) { m_matrix.set(m_row, m_col, v.m_matrix.get_elem(v.m_row, v.m_col)); return *this; }
+ 
+         operator T () const { return m_matrix.get_elem(m_row, m_col); }
+     };
+diff --git a/src/math/lp/static_matrix_def.h b/src/math/lp/static_matrix_def.h
+index 0370ee899..c3b2fc168 100644
+--- a/src/math/lp/static_matrix_def.h
++++ b/src/math/lp/static_matrix_def.h
+@@ -92,7 +92,7 @@ static_matrix<T, X>::static_matrix(static_matrix const &A, unsigned * /* basis *
+     init_row_columns(m, m);
+     for (; m-- > 0; ) 
+         for (auto & col : A.m_columns[m]) 
+-            set(col.var(), m, A.get_value_of_column_cell(col));
++            set(col.var(), m, A.get_column_cell(col));
+ }
+ 
+ template <typename T, typename X> void static_matrix<T, X>::clear() {
+
