diff --git a/ryu/common.h b/ryu/common.h
index 7dc1309..49f1023 100644
--- a/ryu/common.h
+++ b/ryu/common.h
@@ -95,7 +95,7 @@ static inline int copy_special_str(char * const result, const bool sign, const b
     memcpy(result + sign, "Infinity", 8);
     return sign + 8;
   }
-  memcpy(result + sign, "0E0", 3);
+  memcpy(result + sign, "0.0", 3);
   return sign + 3;
 }
 
diff --git a/ryu/d2s.c b/ryu/d2s.c
index 41de875..1073946 100644
--- a/ryu/d2s.c
+++ b/ryu/d2s.c
@@ -60,7 +60,9 @@ static inline uint32_t decimalLength17(const uint64_t v) {
   // The average output length is 16.38 digits, so we check high-to-low.
   // Function precondition: v is not an 18, 19, or 20-digit number.
   // (17 digits are sufficient for round-tripping.)
-  assert(v < 100000000000000000L);
+  assert(v < 10000000000000000000L);
+  if (v >= 1000000000000000000L) { return 19; }
+  if (v >= 100000000000000000L) { return 18; }
   if (v >= 10000000000000000L) { return 17; }
   if (v >= 1000000000000000L) { return 16; }
   if (v >= 100000000000000L) { return 15; }
@@ -203,6 +205,10 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_
 #endif
 
   // Step 4: Find the shortest decimal representation in the interval of valid representations.
+  int32_t vplength = decimalLength17(vp);
+  int32_t exp1 = e10 + vplength - 1;
+  // printf("exp: %d\n", exp1);
+  bool scientificNotation = !((exp1 >= -3) && (exp1 < 7));
   int32_t removed = 0;
   uint8_t lastRemovedDigit = 0;
   uint64_t output;
@@ -215,6 +221,10 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_
       if (vpDiv10 <= vmDiv10) {
         break;
       }
+      if ((vp < 100) && scientificNotation) {
+        // Double.toString semantics requires printing at least two digits.
+        break;
+      }
       const uint32_t vmMod10 = ((uint32_t) vm) - 10 * ((uint32_t) vmDiv10);
       const uint64_t vrDiv10 = div10(vr);
       const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
@@ -237,6 +247,10 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_
         if (vmMod10 != 0) {
           break;
         }
+        if ((vp < 100) && scientificNotation) {
+          // Double.toString semantics requires printing at least two digits.
+          break;
+        }
         const uint64_t vpDiv10 = div10(vp);
         const uint64_t vrDiv10 = div10(vr);
         const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
@@ -261,16 +275,19 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_
   } else {
     // Specialized for the common case (~99.3%). Percentages below are relative to this.
     bool roundUp = false;
-    const uint64_t vpDiv100 = div100(vp);
-    const uint64_t vmDiv100 = div100(vm);
-    if (vpDiv100 > vmDiv100) { // Optimization: remove two digits at a time (~86.2%).
-      const uint64_t vrDiv100 = div100(vr);
-      const uint32_t vrMod100 = ((uint32_t) vr) - 100 * ((uint32_t) vrDiv100);
-      roundUp = vrMod100 >= 50;
-      vr = vrDiv100;
-      vp = vpDiv100;
-      vm = vmDiv100;
-      removed += 2;
+    // Double.toString semantics requires printing at least two digits.
+    if (!((vp < 100) && scientificNotation)) {
+      const uint64_t vpDiv100 = div100(vp);
+      const uint64_t vmDiv100 = div100(vm);
+      if (vpDiv100 > vmDiv100) { // Optimization: remove two digits at a time (~86.2%).
+        const uint64_t vrDiv100 = div100(vr);
+        const uint32_t vrMod100 = ((uint32_t) vr) - 100 * ((uint32_t) vrDiv100);
+        roundUp = vrMod100 >= 50;
+        vr = vrDiv100;
+        vp = vpDiv100;
+        vm = vmDiv100;
+        removed += 2;
+      }
     }
     // Loop iterations below (approximately), without optimization above:
     // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%
@@ -282,6 +299,10 @@ static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_
       if (vpDiv10 <= vmDiv10) {
         break;
       }
+      if ((vp < 100) && scientificNotation) {
+        // Double.toString semantics requires printing at least two digits.
+        break;
+      }
       const uint64_t vrDiv10 = div10(vr);
       const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
       roundUp = vrMod10 >= 5;
@@ -327,93 +348,156 @@ static inline int to_chars(const floating_decimal_64 v, const bool sign, char* c
   printf("EXP=%u\n", v.exponent + olength);
 #endif
 
-  // Print the decimal digits.
-  // The following code is equivalent to:
-  // for (uint32_t i = 0; i < olength - 1; ++i) {
-  //   const uint32_t c = output % 10; output /= 10;
-  //   result[index + olength - i] = (char) ('0' + c);
-  // }
-  // result[index] = '0' + output % 10;
-
-  uint32_t i = 0;
-  // We prefer 32-bit operations, even on 64-bit platforms.
-  // We have at most 17 digits, and uint32_t can store 9 digits.
-  // If output doesn't fit into uint32_t, we cut off 8 digits,
-  // so the rest will fit into uint32_t.
-  if ((output >> 32) != 0) {
-    // Expensive 64-bit division.
-    const uint64_t q = div1e8(output);
-    uint32_t output2 = ((uint32_t) output) - 100000000 * ((uint32_t) q);
-    output = q;
-
-    const uint32_t c = output2 % 10000;
-    output2 /= 10000;
-    const uint32_t d = output2 % 10000;
-    const uint32_t c0 = (c % 100) << 1;
-    const uint32_t c1 = (c / 100) << 1;
-    const uint32_t d0 = (d % 100) << 1;
-    const uint32_t d1 = (d / 100) << 1;
-    memcpy(result + index + olength - 1, DIGIT_TABLE + c0, 2);
-    memcpy(result + index + olength - 3, DIGIT_TABLE + c1, 2);
-    memcpy(result + index + olength - 5, DIGIT_TABLE + d0, 2);
-    memcpy(result + index + olength - 7, DIGIT_TABLE + d1, 2);
-    i += 8;
-  }
-  uint32_t output2 = (uint32_t) output;
-  while (output2 >= 10000) {
-#ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
-    const uint32_t c = output2 - 10000 * (output2 / 10000);
-#else
-    const uint32_t c = output2 % 10000;
-#endif
-    output2 /= 10000;
-    const uint32_t c0 = (c % 100) << 1;
-    const uint32_t c1 = (c / 100) << 1;
-    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
-    memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
-    i += 4;
-  }
-  if (output2 >= 100) {
-    const uint32_t c = (output2 % 100) << 1;
-    output2 /= 100;
-    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
-    i += 2;
-  }
-  if (output2 >= 10) {
-    const uint32_t c = output2 << 1;
-    // We can't use memcpy here: the decimal dot goes between these two digits.
-    result[index + olength - i] = DIGIT_TABLE[c + 1];
-    result[index] = DIGIT_TABLE[c];
-  } else {
-    result[index] = (char) ('0' + output2);
-  }
+  /// Plain format without exponent
+  int32_t exp = v.exponent + (int32_t) olength - 1;
+  if (exp >= -3 && exp < 7)
+  {
+    if (exp < 0)
+    {
+        result[index++] = '0';
+        result[index++] = '.';
+
+        while (++exp)
+            result[index++] = '0';
+
+        for (int32_t i = olength - 1; i >= 0; --i)
+        {
+            const uint32_t c = output % 10;
+            output /= 10;
+            result[index + i] = '0' + c;
+        }
+        index += olength;
+    }
+    else if (exp + 1 >= olength)
+    {
+        for (int32_t i = olength - 1; i >= 0; --i)
+        {
+            const uint32_t c = output % 10;
+            output /= 10;
+            result[index + i] = '0' + c;
+        }
+        index += olength;
 
-  // Print decimal point if needed.
-  if (olength > 1) {
-    result[index + 1] = '.';
-    index += olength + 1;
-  } else {
-    ++index;
+        while (exp >= olength)
+        {
+            result[index++] = '0';
+            --exp;
+        }
+        result[index++] = '.';
+        result[index++] = '0';
+    }
+    else
+    {
+        for (int32_t i = olength; i > exp + 1; --i)
+        {
+            const uint32_t c = output % 10;
+            output /= 10;
+            result[index + i] = '0' + c;
+        }
+        result[index + exp + 1] = '.';
+        for (int32_t i = exp; i >= 0; --i)
+        {
+            const uint32_t c = output % 10;
+            output /= 10;
+            result[index + i] = '0' + c;
+        }
+        index += olength + 1;
+    }
+
+    return index;
   }
 
-  // Print the exponent.
-  result[index++] = 'E';
-  int32_t exp = v.exponent + (int32_t) olength - 1;
-  if (exp < 0) {
-    result[index++] = '-';
-    exp = -exp;
+  {
+    // Print the decimal digits.
+    // The following code is equivalent to:
+    // for (uint32_t i = 0; i < olength - 1; ++i) {
+    //   const uint32_t c = output % 10; output /= 10;
+    //   result[index + olength - i] = (char) ('0' + c);
+    // }
+    // result[index] = '0' + output % 10;
+
+    uint32_t i = 0;
+    // We prefer 32-bit operations, even on 64-bit platforms.
+    // We have at most 17 digits, and uint32_t can store 9 digits.
+    // If output doesn't fit into uint32_t, we cut off 8 digits,
+    // so the rest will fit into uint32_t.
+    if ((output >> 32) != 0) {
+        // Expensive 64-bit division.
+        const uint64_t q = div1e8(output);
+        uint32_t output2 = ((uint32_t) output) - 100000000 * ((uint32_t) q);
+        output = q;
+
+        const uint32_t c = output2 % 10000;
+        output2 /= 10000;
+        const uint32_t d = output2 % 10000;
+        const uint32_t c0 = (c % 100) << 1;
+        const uint32_t c1 = (c / 100) << 1;
+        const uint32_t d0 = (d % 100) << 1;
+        const uint32_t d1 = (d / 100) << 1;
+        memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
+        memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
+        memcpy(result + index + olength - i - 5, DIGIT_TABLE + d0, 2);
+        memcpy(result + index + olength - i - 7, DIGIT_TABLE + d1, 2);
+        i += 8;
+    }
+    uint32_t output2 = (uint32_t) output;
+    while (output2 >= 10000) {
+    #ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
+        const uint32_t c = output2 - 10000 * (output2 / 10000);
+    #else
+        const uint32_t c = output2 % 10000;
+    #endif
+        output2 /= 10000;
+        const uint32_t c0 = (c % 100) << 1;
+        const uint32_t c1 = (c / 100) << 1;
+        memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
+        memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
+        i += 4;
+    }
+    if (output2 >= 100) {
+        const uint32_t c = (output2 % 100) << 1;
+        output2 /= 100;
+        memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
+        i += 2;
+    }
+    if (output2 >= 10) {
+        const uint32_t c = output2 << 1;
+        // We can't use memcpy here: the decimal dot goes between these two digits.
+        result[index + olength - i] = DIGIT_TABLE[c + 1];
+        result[index] = DIGIT_TABLE[c];
+    } else {
+        result[index] = (char) ('0' + output2);
+    }
+
+    // Print decimal point if needed.
+    if (olength > 1) {
+        result[index + 1] = '.';
+        index += olength + 1;
+    } else {
+        ++index;
+    }
   }
 
-  if (exp >= 100) {
-    const int32_t c = exp % 10;
-    memcpy(result + index, DIGIT_TABLE + 2 * (exp / 10), 2);
-    result[index + 2] = (char) ('0' + c);
-    index += 3;
-  } else if (exp >= 10) {
-    memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
-    index += 2;
-  } else {
-    result[index++] = (char) ('0' + exp);
+  {
+    // Print the exponent
+    result[index++] = 'E';
+
+    if (exp < 0) {
+        result[index++] = '-';
+        exp = -exp;
+    }
+
+    if (exp >= 100) {
+        const int32_t c = exp % 10;
+        memcpy(result + index, DIGIT_TABLE + 2 * (exp / 10), 2);
+        result[index + 2] = (char) ('0' + c);
+        index += 3;
+    } else if (exp >= 10) {
+        memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
+        index += 2;
+    } else {
+        result[index++] = (char) ('0' + exp);
+    }
   }
 
   return index;
@@ -472,25 +556,7 @@ int d2s_buffered_n(double f, char* result) {
     return copy_special_str(result, ieeeSign, ieeeExponent, ieeeMantissa);
   }
 
-  floating_decimal_64 v;
-  const bool isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, &v);
-  if (isSmallInt) {
-    // For small integers in the range [1, 2^53), v.mantissa might contain trailing (decimal) zeros.
-    // For scientific notation we need to move these zeros into the exponent.
-    // (This is not needed for fixed-point notation, so it might be beneficial to trim
-    // trailing zeros in to_chars only if needed - once fixed-point notation output is implemented.)
-    for (;;) {
-      const uint64_t q = div10(v.mantissa);
-      const uint32_t r = ((uint32_t) v.mantissa) - 10 * ((uint32_t) q);
-      if (r != 0) {
-        break;
-      }
-      v.mantissa = q;
-      ++v.exponent;
-    }
-  } else {
-    v = d2d(ieeeMantissa, ieeeExponent);
-  }
+  floating_decimal_64 v = d2d(ieeeMantissa, ieeeExponent);
 
   return to_chars(v, ieeeSign, result);
 }
diff --git a/ryu/d2s_intrinsics.h b/ryu/d2s_intrinsics.h
index 426ed8f..377b668 100644
--- a/ryu/d2s_intrinsics.h
+++ b/ryu/d2s_intrinsics.h
@@ -94,8 +94,14 @@ static inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* con
 static inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
   // We don't need to handle the case dist >= 64 here (see above).
   assert(dist < 64);
+#if defined(RYU_OPTIMIZE_SIZE) || !defined(RYU_32_BIT_PLATFORM)
   assert(dist > 0);
   return (hi << (64 - dist)) | (lo >> dist);
+#else
+  // Avoid a 64-bit shift by taking advantage of the range of shift values.
+  assert(dist >= 32);
+  return (hi << (64 - dist)) | ((uint32_t)(lo >> 32) >> (dist - 32));
+#endif
 }
 
 #endif // defined(HAS_64_BIT_INTRINSICS)
@@ -189,14 +195,15 @@ static inline uint32_t mod1e9(const uint64_t x) {
 #endif // defined(RYU_32_BIT_PLATFORM)
 
 static inline uint32_t pow5Factor(uint64_t value) {
-  const uint64_t m_inv_5 = 14757395258967641293u; // 5 * m_inv_5 = 1 (mod 2^64)
-  const uint64_t n_div_5 = 3689348814741910323u;  // #{ n | n = 0 (mod 2^64) } = 2^64 / 5
   uint32_t count = 0;
   for (;;) {
     assert(value != 0);
-    value *= m_inv_5;
-    if (value > n_div_5)
+    const uint64_t q = div5(value);
+    const uint32_t r = ((uint32_t) value) - 5 * ((uint32_t) q);
+    if (r != 0) {
       break;
+    }
+    value = q;
     ++count;
   }
   return count;
@@ -211,7 +218,6 @@ static inline bool multipleOfPowerOf5(const uint64_t value, const uint32_t p) {
 // Returns true if value is divisible by 2^p.
 static inline bool multipleOfPowerOf2(const uint64_t value, const uint32_t p) {
   assert(value != 0);
-  assert(p < 64);
   // __builtin_ctzll doesn't appear to be faster here.
   return (value & ((1ull << p) - 1)) == 0;
 }
diff --git a/ryu/d2s_small_table.h b/ryu/d2s_small_table.h
index 22940d6..456b02e 100644
--- a/ryu/d2s_small_table.h
+++ b/ryu/d2s_small_table.h
@@ -24,7 +24,7 @@
 #define DOUBLE_POW5_INV_BITCOUNT 125
 #define DOUBLE_POW5_BITCOUNT 125
 
-static const uint64_t DOUBLE_POW5_INV_SPLIT2[15][2] = {
+static const uint64_t DOUBLE_POW5_INV_SPLIT2[13][2] = {
   {                    1u, 2305843009213693952u },
   {  5955668970331000884u, 1784059615882449851u },
   {  8982663654677661702u, 1380349269358112757u },
@@ -37,9 +37,7 @@ static const uint64_t DOUBLE_POW5_INV_SPLIT2[15][2] = {
   {  1527430471115325346u, 1832889850782397517u },
   { 12533209867169019542u, 1418129833677084982u },
   {  5577825024675947042u, 2194449627517475473u },
-  { 11006974540203867551u, 1697873161311732311u },
-  { 10313493231639821582u, 1313665730009899186u },
-  { 12701016819766672773u, 2032799256770390445u }
+  { 11006974540203867551u, 1697873161311732311u }
 };
 static const uint32_t POW5_INV_OFFSETS[19] = {
   0x54544554, 0x04055545, 0x10041000, 0x00400414, 0x40010000, 0x41155555,
diff --git a/ryu/f2s.c b/ryu/f2s.c
index 255ecbe..95c34d4 100644
--- a/ryu/f2s.c
+++ b/ryu/f2s.c
@@ -152,11 +152,22 @@ static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_
 #endif
 
   // Step 4: Find the shortest decimal representation in the interval of valid representations.
+  // We do some extra work here in order to follow Float/Double.toString semantics. In particular,
+  // that requires printing in scientific format if and only if the exponent is between -3 and 7,
+  // and it requires printing at least two decimal digits.
+  int dplength = decimalLength9(vp);
+  int exp1 = e10 + dplength - 1;
+  // Float.toString semantics requires using scientific notation if and only if outside this range.
+  bool scientificNotation = !((exp1 >= -3) && (exp1 < 7));
   int32_t removed = 0;
   uint32_t output;
   if (vmIsTrailingZeros || vrIsTrailingZeros) {
     // General case, which happens rarely (~4.0%).
     while (vp / 10 > vm / 10) {
+      if ((vp < 100) && scientificNotation) {
+        // We print at least two digits, so we might as well stop now.
+        break;
+      }
 #ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=23106
       // The compiler does not realize that vm % 10 can be computed from vm / 10
       // as vm - (vm / 10) * 10.
@@ -175,20 +186,22 @@ static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_
     printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
     printf("d-10=%s\n", vmIsTrailingZeros ? "true" : "false");
 #endif
-    if (vmIsTrailingZeros) {
-      while (vm % 10 == 0) {
-        vrIsTrailingZeros &= lastRemovedDigit == 0;
-        lastRemovedDigit = (uint8_t) (vr % 10);
-        vr /= 10;
-        vp /= 10;
-        vm /= 10;
-        ++removed;
-      }
-    }
-#ifdef RYU_DEBUG
-    printf("%u %d\n", vr, lastRemovedDigit);
-    printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
-#endif
+// in order to be consistent with java Float.toString, delete the part from line 191 to line 204.
+// ASSERT_F2S("1.23456784E8", 123456780.0f); ASSERT_F2S("1.2345678E8", 123456780.0f);
+//     if (vmIsTrailingZeros) {
+//       while (vm % 10 == 0) {
+//         vrIsTrailingZeros &= lastRemovedDigit == 0;
+//         lastRemovedDigit = (uint8_t) (vr % 10);
+//         vr /= 10;
+//         vp /= 10;
+//         vm /= 10;
+//         ++removed;
+//       }
+//     }
+// #ifdef RYU_DEBUG
+//     printf("%u %d\n", vr, lastRemovedDigit);
+//     printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
+// #endif
     if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
       // Round even if the exact number is .....50..0.
       lastRemovedDigit = 4;
@@ -200,6 +213,10 @@ static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_
     // Loop iterations below (approximately):
     // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
     while (vp / 10 > vm / 10) {
+      if ((vp < 100) && scientificNotation) {
+        // We print at least two digits, so we might as well stop now.
+        break;
+      }
       lastRemovedDigit = (uint8_t) (vr % 10);
       vr /= 10;
       vp /= 10;
@@ -243,6 +260,8 @@ static inline int to_chars(const floating_decimal_32 v, const bool sign, char* c
   printf("EXP=%u\n", v.exponent + olength);
 #endif
 
+  int32_t exp1 = v.exponent + (int32_t) olength - 1;
+  bool scientificNotation = !((exp1 >= -3) && (exp1 < 7));
   // Print the decimal digits.
   // The following code is equivalent to:
   // for (uint32_t i = 0; i < olength - 1; ++i) {
@@ -250,56 +269,98 @@ static inline int to_chars(const floating_decimal_32 v, const bool sign, char* c
   //   result[index + olength - i] = (char) ('0' + c);
   // }
   // result[index] = '0' + output % 10;
-  uint32_t i = 0;
-  while (output >= 10000) {
-#ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
-    const uint32_t c = output - 10000 * (output / 10000);
-#else
-    const uint32_t c = output % 10000;
-#endif
-    output /= 10000;
-    const uint32_t c0 = (c % 100) << 1;
-    const uint32_t c1 = (c / 100) << 1;
-    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
-    memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
-    i += 4;
-  }
-  if (output >= 100) {
-    const uint32_t c = (output % 100) << 1;
-    output /= 100;
-    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
-    i += 2;
-  }
-  if (output >= 10) {
-    const uint32_t c = output << 1;
-    // We can't use memcpy here: the decimal dot goes between these two digits.
-    result[index + olength - i] = DIGIT_TABLE[c + 1];
-    result[index] = DIGIT_TABLE[c];
-  } else {
-    result[index] = (char) ('0' + output);
-  }
+  if (scientificNotation) {
+    uint32_t i = 0;
+    while (output >= 10000) {
+  #ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
+      const uint32_t c = output - 10000 * (output / 10000);
+  #else
+      const uint32_t c = output % 10000;
+  #endif
+      output /= 10000;
+      const uint32_t c0 = (c % 100) << 1;
+      const uint32_t c1 = (c / 100) << 1;
+      memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
+      memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
+      i += 4;
+    }
+    if (output >= 100) {
+      const uint32_t c = (output % 100) << 1;
+      output /= 100;
+      memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
+      i += 2;
+    }
+    if (output >= 10) {
+      const uint32_t c = output << 1;
+      // We can't use memcpy here: the decimal dot goes between these two digits.
+      result[index + olength - i] = DIGIT_TABLE[c + 1];
+      result[index] = DIGIT_TABLE[c];
+    } else {
+      result[index] = (char) ('0' + output);
+    }
 
-  // Print decimal point if needed.
-  if (olength > 1) {
-    result[index + 1] = '.';
-    index += olength + 1;
-  } else {
-    ++index;
-  }
+    // Print decimal point if needed.
+    if (olength > 1) {
+      result[index + 1] = '.';
+      index += olength + 1;
+    } else {
+      ++index;
+    }
 
-  // Print the exponent.
-  result[index++] = 'E';
-  int32_t exp = v.exponent + (int32_t) olength - 1;
-  if (exp < 0) {
-    result[index++] = '-';
-    exp = -exp;
-  }
+    // Print the exponent.
+    result[index++] = 'E';
+    int32_t exp = v.exponent + (int32_t) olength - 1;
+    if (exp < 0) {
+      result[index++] = '-';
+      exp = -exp;
+    }
 
-  if (exp >= 10) {
-    memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
-    index += 2;
+    if (exp >= 10) {
+      memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
+      index += 2;
+    } else {
+      result[index++] = (char) ('0' + exp);
+    }
   } else {
-    result[index++] = (char) ('0' + exp);
+    int32_t exp = v.exponent + (int32_t) olength - 1;
+    if (exp < 0) {
+        // Decimal dot is before any of the digits.
+        result[index++] = '0';
+        result[index++] = '.';
+        for (int i = -1; i > exp; i--) {
+          result[index++] = '0';
+        }
+        int current = index;
+        for (int i = 0; i < olength; i++) {
+          result[current + olength - i - 1] = (char) ('0' + output % 10);
+          output /= 10;
+          index++;
+        }
+      } else if (exp + 1 >= olength) {
+        // Decimal dot is after any of the digits.
+        for (int i = 0; i < olength; i++) {
+          result[index + olength - i - 1] = (char) ('0' + output % 10);
+          output /= 10;
+        }
+        index += olength;
+        for (int i = olength; i < exp + 1; i++) {
+          result[index++] = '0';
+        }
+        result[index++] = '.';
+        result[index++] = '0';
+      } else {
+        // Decimal dot is somewhere between the digits.
+        int current = index + 1;
+        for (int i = 0; i < olength; i++) {
+          if (olength - i - 1 == exp) {
+            result[current + olength - i - 1] = '.';
+            current--;
+          }
+          result[current + olength - i - 1] = (char) ('0' + output % 10);
+          output /= 10;
+        }
+        index += olength + 1;
+      }
   }
 
   return index;
diff --git a/ryu/ryu.h b/ryu/ryu.h
index 558822a..009da59 100644
--- a/ryu/ryu.h
+++ b/ryu/ryu.h
@@ -14,6 +14,27 @@
 // Unless required by applicable law or agreed to in writing, this software
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 // KIND, either express or implied.
+
+/*
+ * Copyright (c) 2025 ByteDance Ltd. and/or its affiliates
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* This file is the original Ryu library v2.0 with minor modifications to be
+ * compatible with Java. Note that, it is not 100% compatible with java now
+ * TODO: make it fully compatible with java.
+ */
 #ifndef RYU_H
 #define RYU_H
 
